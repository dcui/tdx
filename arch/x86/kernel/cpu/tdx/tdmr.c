// SPDX-License-Identifier: GPL-2.0
/*
 * Copyright(c) 2021 Intel Corporation.
 *
 * Intel Trusted Domain Extensions (TDX) memory initialization
 */

#define pr_fmt(fmt) "tdx: " fmt

#include <linux/types.h>
#include <linux/errno.h>
#include <linux/sizes.h>
#include <asm/e820/api.h>
#include "tdmr.h"

/*
 * Return whether the given e820 entry is RAM entry, and can be used
 * as TDX memory.  Note besides E820_TYPE_RAM, E820_TYPE_PRAM is also
 * considered as RAM since underneath it is RAM.  If user enables PRAM
 * via kernel command line on TDX enabled system, user is likely to want
 * to use PRAM as TD guest memory.
 *
 * Other types such as E820_TYPE_RESERVED_KERN or E820_TYPE_SOFT_RESERVED
 * may underneath also be RAM but they won't be used as TD guest memory
 * so they are not treated as RAM entries.
 */
static bool e820_entry_is_ram(struct e820_entry *entry)
{
	return (entry->type == E820_TYPE_RAM) ||
		(entry->type == E820_TYPE_PRAM);
}

/*
 * Get the memory region that is used by TDX for given e820 RAM entry
 * by skipping memory below 1MB.  In practice, memory below 1MB is not
 * included in CMRs generated by BIOS.  Don't treat those as TDX memory
 * so that they are not checked against CMRs and are not included into
 * TDMR's usable memory regions.  And skipping memory below 1MB is OK,
 * since they are reserved during kernel boot in setup_arch() and won't
 * be managed by page allocator anyway.
 *
 * Return true if the e820 entry is not completely skipped, in which case
 * the actual memory region after skipping memory below 1MB is returned
 * via @start and @end.  Otherwise caller should ignore this entry.
 */
static bool e820_entry_skip_lowmem(struct e820_entry *entry, u64 *start,
				   u64 *end)
{
	u64 _start = entry->addr;
	u64 _end = entry->addr + entry->size;

	if (_start < SZ_1M)
		_start = SZ_1M;

	*start = _start;
	*end = _end;

	return _start < _end;
}

/*
 * Helper to loop over all RAM entries which are used as TDX memory
 * in e820 table.  Both RAM and PRAM entries are treated as TDX memory.
 * Memory below 1MB is skipped.
 */
#define e820_for_each_ram_entry(_table, _i, _entry, _start, _end)	\
	for ((_i) = 0, (_entry) = &(_table)->entries[0];		\
			(_i) < (_table)->nr_entries;			\
			(_i)++, (_entry) = &(_table)->entries[(_i)])	\
		if (!e820_entry_is_ram((_entry)) ||			\
			!e820_entry_skip_lowmem((_entry),		\
				&(_start), &(_end))) { }		\
		else

/* Check whether first range is the subrange of the second */
static bool is_subrange(u64 r1_start, u64 r1_end, u64 r2_start, u64 r2_end)
{
	return (r1_start >= r2_start && r1_end <= r2_end) ? true : false;
}

/* Check whether address range is covered by any CMR or not. */
static bool range_covered_by_cmrs(struct cmr_info *cmr_array,
				  int cmr_num, u64 start, u64 end)
{
	int i;

	for (i = 0; i < cmr_num; i++) {
		struct cmr_info *cmr = &cmr_array[i];

		if (is_subrange(start, end, cmr->base, cmr->base + cmr->size))
			return true;
	}

	return false;
}

/*
 * Sanity check whether all e820 table RAM entries are fully
 * covered by CMRs.
 */
static int check_e820_against_cmrs(struct cmr_info *cmr_array, int cmr_num)
{
	struct e820_entry *entry;
	u64 start, end;
	int i;

	/*
	 * Loop over e820_table to find all RAM entries and check them
	 * against CMRs to see whether they are all fully covered by
	 * CMR.  Use e820_table instead of e820_table_firmware or
	 * e820_table_kexec to honor possible 'mem' and 'memmap' kernel
	 * command line.
	 */
	e820_for_each_ram_entry(e820_table, i, entry, start, end) {
		/*
		 * Check whether RAM entry is fully covered by any CMR.
		 * Only convertible memory can truly be used by TDX.
		 * If it is not, likely BIOS didn't generate CMRs
		 * correctly.  Give a message in this case.
		 */
		if (!range_covered_by_cmrs(cmr_array, cmr_num, start, end)) {
			pr_err("[0x%llx, 0x%llx) not fully convertible memory\n",
					start, end);
			return -EFAULT;
		}
	}

	return 0;
}

/**
 * construct_tdmrs - Construct TDMRs to cover all system RAM in e820
 *
 * @cmr_array:	Array of CMR_INFO
 * @cmr_num:	Number of CMR_INFO entries
 * @tdmr_array:	Array of constructed TDMRs
 * @desc:	TDX module descriptor for constructing TMDRs
 * @tdmr_num:	Actual number of TDMRs
 *
 * Construct TDMRs to cover all RAM entries in e820_table to convert
 * all system RAM to TDX memory.  The constructed TDMRs are stored in
 * @tdmr_array, with @tdmr_num reflects the actual TDMR number.
 *
 * Caller is responsible for allocating enough space for the array of
 * TDMRs.
 *
 * Return: 0 for success, or error.
 */
int construct_tdmrs(struct cmr_info *cmr_array, int cmr_num,
		    struct tdmr_info *tdmr_array,
		    struct tdx_module_descriptor *desc,
		    int *tdmr_num)
{
	return check_e820_against_cmrs(cmr_array, cmr_num);
}
